var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = FuncType","category":"page"},{"location":"#FuncType","page":"Home","title":"FuncType","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FuncType.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FuncType]","category":"page"},{"location":"#FuncType.funcargtype-Union{Tuple{FunctionType{R, T}}, Tuple{T}, Tuple{R}} where {R, T}","page":"Home","title":"FuncType.funcargtype","text":"funcargtype(::FunctionType)\n\nGet the argument type of the given type signature, must be subtype of Tuple.\n\n\n\n\n\n","category":"method"},{"location":"#FuncType.funcrettype-Union{Tuple{FunctionType{R}}, Tuple{R}} where R","page":"Home","title":"FuncType.funcrettype","text":"funcrettype(::FunctionType)\n\nGet the return type of the given type signature.\n\n\n\n\n\n","category":"method"},{"location":"#FuncType.@Func-Tuple{Any}","page":"Home","title":"FuncType.@Func","text":"@Func(<func type sig>)\n\nCreate a FunctionType with function type signature syntax. Because Julia function are not curried,  function with multiple argument need to be explicitly wrap with parenthesis. On the other hand, Tuple  input need to be specified as something like Tuple{A, B}.\n\nExample\n\njulia> @Func Int -> Int   # single input single output\nFunctionType : Int64 -> Int64\n\njulia> @Func (Int, Float64) -> Float64   # multiple input single output\nFunctionType : (Int64, Float64) -> Float64\n\njulia> @Func Int -> (Float64, Float64)   # single input multiple output\nFunctionType : Int64 -> (Float64, Float64)\n\njulia> @Func (Int, Int) -> (Float64, Float64)   # multiple input multiple output\nFunctionType : (Int64, Int64) -> (Float64, Float64)\n\njulia> @Func () -> Int   # no input\nFunctionType : () -> Int64\n\njulia> @Func Tuple{A, A} -> A   # single tuple input\nFunctionType : Tuple{var\"#133#A\", var\"#133#A\"} -> var\"#133#A\"\n\njulia> @Func (Tuple{A, B}, B) -> C   # multiple input with tuple argument\nFunctionType : (Tuple{var\"#134#A\", var\"#135#B\"}, var\"#135#B\") -> var\"#136#C\"\n\njulia> @Func T -> T   # type var\nFunctionType : var\"#137#T\" -> var\"#137#T\"\n\njulia> @Func @NamedTuple{x::A, y::A} -> A   # nested macro\nFunctionType : NamedTuple{(:x, :y), Tuple{var\"#138#A\", var\"#138#A\"}} -> var\"#138#A\"\n\njulia> @Func (@Func(A -> B), Vector{A}) -> Vector{B}   # higher-order function: `map`\nFunctionType : (var\"#139#A\" -> var\"#140#B\", Array{var\"#139#A\", 1}) -> Array{var\"#140#B\", 1}\n\njulia> @Func Vector{@Func(A->A)} -> A   # container of function\nFunctionType : Array{(var\"#141#A\" -> var\"#141#A\"), 1} -> var\"#141#A\"\n\njulia> @Func ((C, A)->(C, B), C, Vector{A}) -> (C, Vector{B})   # scan :: (c -> a -> (c, b)) -> c -> [a] -> (c, [b])\nFunctionType : ((var\"#145#C\", var\"#143#A\") -> (var\"#145#C\", var\"#144#B\"), var\"#145#C\", Array{var\"#143#A\", 1}) -> (var\"#145#C\", Array{var\"#144#B\", 1})\n\n\n\n\n\n\n","category":"macro"},{"location":"#FuncType.@functype-Tuple{Any}","page":"Home","title":"FuncType.@functype","text":"@functype function <func name>(<arg with type sig>)::<ret type> where {<parameters, if any>}\n    <func body>\nend\n\nIf ret type is missing, assuming the function return nothing\n\n\n\n\n\n","category":"macro"}]
}
