var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = FuncType","category":"page"},{"location":"#FuncType","page":"Home","title":"FuncType","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FuncType.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FuncType]","category":"page"},{"location":"#FuncType.@Func-Tuple{Any}","page":"Home","title":"FuncType.@Func","text":"@Func(<func type sig>)\n\nCreate a FunctionType with function type signature syntax. Because Julia function are not curried,  function with multiple argument need to be explicitly wrap with parenthesis. On the other hand, Tuple  input need to be specified as something like Tuple{A, B}.\n\nExample\n\njulia> @Func Int -> Int   # single input single output\nFunctionType{Int64, Tuple{Int64}}\n\njulia> @Func (Int, Float64) -> Float64   # multiple input single output\nFunctionType{Float64, Tuple{Int64, Float64}}\n\njulia> @Func Int -> (Float64, Float64)   # single input multiple output\nFunctionType{Tuple{Float64, Float64}, Tuple{Int64}}\n\njulia> @Func (Int, Int) -> (Float64, Float64)   # multiple input multiple output\nFunctionType{Tuple{Float64, Float64}, Tuple{Int64, Int64}}\n\njulia> @Func () -> Int   # no input\nFunctionType{Int64, Tuple{}}\n\njulia> @Func Tuple{A, A} -> A   # single tuple input\nFunctionType{var\"#41#A\", Tuple{Tuple{var\"#41#A\", var\"#41#A\"}}} where var\"#41#A\"\n\njulia> @Func (Tuple{A, B}, B) -> C   # multiple input with tuple argument\nFunctionType{<:Any, Tuple{Tuple{var\"#42#A\", var\"#43#B\"}, var\"#43#B\"}} where {var\"#42#A\", var\"#43#B\"}\n\njulia> @Func T -> T   # type var\nFunctionType{var\"#30#T\", Tuple{var\"#30#T\"}} where var\"#30#T\"\n\njulia> @Func @NamedTuple{x::A, y::A} -> A   # nested macro\nFunctionType{var\"#40#A\", Tuple{NamedTuple{(:x, :y), Tuple{var\"#40#A\", var\"#40#A\"}}}} where var\"#40#A\"\n\njulia> @Func (@Func(A -> B), Vector{A}) -> Vector{B}   # higher-order function: `map`\nFunctionType{Vector{var\"#15#B\"}, Tuple{FunctionType{var\"#15#B\", Tuple{var\"#14#A\"}}, Vector{var\"#14#A\"}}} where {var\"#14#A\", var\"#15#B\"}\n\njulia> @Func ((C, A)->(C, B), C, Vector{A}) -> (C, Vector{B})   # scan :: (c -> a -> (c, b)) -> c -> [a] -> (c, [b])\nFunctionType{Tuple{var\"#47#C\", Vector{var\"#46#B\"}}, Tuple{FunctionType{Tuple{var\"#47#C\", var\"#46#B\"}, Tuple{var\"#47#C\", var\"#45#A\"}}, var\"#47#C\", Vector{var\"#45#A\"}}} where {var\"#45#A\", var\"#46#B\", var\"#47#C\"}\n\n\n\n\n\n\n","category":"macro"},{"location":"#FuncType.@functype-Tuple{Any}","page":"Home","title":"FuncType.@functype","text":"@functype function <func name>(<arg with type sig>)::<ret type> where {<parameters, if any>}\n    <func body>\nend\n\nIf ret type is missing, assuming the function return nothing\n\n\n\n\n\n","category":"macro"}]
}
